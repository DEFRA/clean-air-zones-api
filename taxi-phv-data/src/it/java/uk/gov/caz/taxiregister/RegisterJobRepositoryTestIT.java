package uk.gov.caz.taxiregister;

import static org.assertj.core.api.Assertions.catchThrowable;
import static uk.gov.caz.testutils.NtrAssertions.assertThat;
import static uk.gov.caz.testutils.TestObjects.MODIFIED_REGISTER_JOB_ERRORS;
import static uk.gov.caz.testutils.TestObjects.NOT_EXISTING_REGISTER_JOB_NAME;
import static uk.gov.caz.testutils.TestObjects.S3_REGISTER_JOB_NAME;
import static uk.gov.caz.testutils.TestObjects.S3_REGISTER_JOB_TRIGGER;
import static uk.gov.caz.testutils.TestObjects.S3_RUNNING_REGISTER_JOB;
import static uk.gov.caz.testutils.TestObjects.TYPICAL_CORRELATION_ID;
import static uk.gov.caz.testutils.TestObjects.TYPICAL_REGISTER_JOB_ERRORS;
import static uk.gov.caz.testutils.TestObjects.TYPICAL_REGISTER_JOB_UPLOADER_ID;
import static uk.gov.caz.testutils.TestObjects.TYPICAL_RUNNING_REGISTER_JOB_STATUS;

import com.google.common.collect.ImmutableSet;
import java.sql.SQLException;
import java.util.Collections;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Stream;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.Sql.ExecutionPhase;
import uk.gov.caz.taxiregister.annotation.IntegrationTest;
import uk.gov.caz.taxiregister.model.LicensingAuthority;
import uk.gov.caz.taxiregister.model.registerjob.RegisterJob;
import uk.gov.caz.taxiregister.model.registerjob.RegisterJobError;
import uk.gov.caz.taxiregister.model.registerjob.RegisterJobStatus;
import uk.gov.caz.taxiregister.model.registerjob.RegisterJobTrigger;
import uk.gov.caz.taxiregister.repository.RegisterJobRepository;
import uk.gov.caz.taxiregister.service.exception.JobNameDuplicateException;

@IntegrationTest
@Sql(scripts = "classpath:data/sql/clear.sql", executionPhase = ExecutionPhase.AFTER_TEST_METHOD)
@Sql(scripts = "classpath:data/sql/clear.sql", executionPhase = ExecutionPhase.BEFORE_TEST_METHOD)
public class RegisterJobRepositoryTestIT {

  @Autowired
  private RegisterJobRepository registerJobRepository;

  @Test
  public void testRegisterJobRepositoryOperations() {
    // Insert
    int autoGeneratedId = insertNewRegisterJob();

    // Find by id
    queryForNewlyInsertedRegisterJob(autoGeneratedId);

    // Find the same job by name
    RegisterJob fetchedRegisterJob = queryForNewlyInsertedRegisterJob(S3_REGISTER_JOB_NAME,
        autoGeneratedId);

    // Update status on entity
    updateStatus(fetchedRegisterJob, RegisterJobStatus.FINISHED_FAILURE_VALIDATION_ERRORS);
    queryForUpdatedRegisterJob(autoGeneratedId,
        RegisterJobStatus.FINISHED_FAILURE_VALIDATION_ERRORS, TYPICAL_REGISTER_JOB_ERRORS);

    // Update status directly on database
    updateStatus(autoGeneratedId, RegisterJobStatus.FINISHED_SUCCESS);
    queryForUpdatedRegisterJob(autoGeneratedId, RegisterJobStatus.FINISHED_SUCCESS,
        TYPICAL_REGISTER_JOB_ERRORS);

    // Update errors directly on database
    updateErrors(autoGeneratedId, MODIFIED_REGISTER_JOB_ERRORS);
    queryForUpdatedRegisterJob(autoGeneratedId, RegisterJobStatus.FINISHED_SUCCESS,
        MODIFIED_REGISTER_JOB_ERRORS);

    // Find by non existing id
    queryForNonExistingRegisterJobById();

    // Find by non existing job name
    queryForNonExistingRegisterJobByName();
  }

  @Test
  @Sql(scripts = {"classpath:data/sql/clear.sql", "classpath:data/sql/licensing-authority-data.sql", "classpath:data/sql/register-job-data.sql"})
  public void shouldReturnNumberOfActivatedJobs() throws SQLException {
    // given
    Set<LicensingAuthority> las = Collections.singleton(LicensingAuthority.withNameOnly("Leeds"));
    // when
    Integer result = registerJobRepository.countActiveJobsBy(las);

    // then
    assertThat(result).isEqualTo(1);
  }

  @Test
  @Sql(scripts = {"classpath:data/sql/clear.sql", "classpath:data/sql/licensing-authority-data.sql", "classpath:data/sql/register-job-data.sql"})
  public void shouldReturnNotActivatedJobs() throws SQLException {
    // given
    Set<LicensingAuthority> las = Collections.singleton(LicensingAuthority.withNameOnly("London"));
    // when
    Integer result = registerJobRepository.countActiveJobsBy(las);
    // then
    assertThat(result).isEqualTo(0);
  }

  @Test
  public void shouldThrowDuplicateKeyException() {
    // given
    insertNewRegisterJob();

    // when
    Throwable throwable = catchThrowable(this::insertNewRegisterJob);

    // then
    assertThat(throwable)
        .isInstanceOf(JobNameDuplicateException.class);
  }

  @ParameterizedTest
  @MethodSource("activatedJobsForGivenLicensingAuthorities")
  @Sql(scripts = {"classpath:data/sql/clear.sql", "classpath:data/sql/licensing-authority-data.sql", "classpath:data/sql/register-job-data.sql"})
  public void shouldFindAlreadyLaunchedJob(Set<LicensingAuthority> las, Integer activatedJobs) throws SQLException {
    // when
    Integer result = registerJobRepository.countActiveJobsBy(las);

    // then
    assertThat(result).isEqualTo(activatedJobs);
  }


  private int insertNewRegisterJob() {
    RegisterJob registerJob = S3_RUNNING_REGISTER_JOB;
    int autoGeneratedId = registerJobRepository.insert(registerJob);
    registerJob.setId(autoGeneratedId);
    checkIfAutoGeneratedIdWasBumpedAndInsertedIntoRegisterJobEntity(registerJob, autoGeneratedId);
    return autoGeneratedId;
  }

  private void checkIfAutoGeneratedIdWasBumpedAndInsertedIntoRegisterJobEntity(
      RegisterJob registerJob, int autoGeneratedId) {
    assertThat(autoGeneratedId).isGreaterThan(0);
    assertThat(registerJob.getId()).isEqualTo(autoGeneratedId);
  }

  private RegisterJob queryForNewlyInsertedRegisterJob(int autoGeneratedId) {
    RegisterJob fetchedRegisterJob = findByIdAndValidateThatItExists(autoGeneratedId);
    validateThatHasProperties(fetchedRegisterJob, autoGeneratedId, S3_REGISTER_JOB_TRIGGER,
        S3_REGISTER_JOB_NAME, TYPICAL_REGISTER_JOB_UPLOADER_ID,
        TYPICAL_RUNNING_REGISTER_JOB_STATUS,
        TYPICAL_REGISTER_JOB_ERRORS, TYPICAL_CORRELATION_ID);
    return fetchedRegisterJob;
  }

  private RegisterJob findByIdAndValidateThatItExists(int id) {
    Optional<RegisterJob> fetchedRegisterJobOptional = registerJobRepository.findById(id);
    assertThat(fetchedRegisterJobOptional).isPresent();
    return fetchedRegisterJobOptional.get();
  }

  private RegisterJob queryForNewlyInsertedRegisterJob(String jobName, int autoGeneratedId) {
    RegisterJob fetchedRegisterJob = findByNameAndValidateThatItExists(jobName);
    validateThatHasProperties(fetchedRegisterJob, autoGeneratedId,
        S3_REGISTER_JOB_TRIGGER,
        S3_REGISTER_JOB_NAME, TYPICAL_REGISTER_JOB_UPLOADER_ID,
        TYPICAL_RUNNING_REGISTER_JOB_STATUS,
        TYPICAL_REGISTER_JOB_ERRORS, TYPICAL_CORRELATION_ID);
    return fetchedRegisterJob;
  }

  private RegisterJob findByNameAndValidateThatItExists(String jobName) {
    Optional<RegisterJob> fetchedRegisterJobOptional = registerJobRepository.findByName(jobName);
    assertThat(fetchedRegisterJobOptional).isPresent();
    return fetchedRegisterJobOptional.get();
  }

  private RegisterJob updateStatus(RegisterJob registerJob, RegisterJobStatus newStatus) {
    RegisterJob updatedRegisterJob = registerJob.toBuilder().status(newStatus).build();
    registerJobRepository.updateStatus(updatedRegisterJob);
    return updatedRegisterJob;
  }

  private void queryForUpdatedRegisterJob(int autoGeneratedId, RegisterJobStatus expectedStatus,
      List<RegisterJobError> expectedErrors) {
    RegisterJob fetchedRegisterJob = findByIdAndValidateThatItExists(autoGeneratedId);
    validateThatHasProperties(fetchedRegisterJob, autoGeneratedId, S3_REGISTER_JOB_TRIGGER,
        S3_REGISTER_JOB_NAME, TYPICAL_REGISTER_JOB_UPLOADER_ID,
        expectedStatus, expectedErrors, TYPICAL_CORRELATION_ID);
  }

  private void updateStatus(int autoGeneratedId, RegisterJobStatus newStatus) {
    registerJobRepository.updateStatus(autoGeneratedId, newStatus);
  }

  private void validateThatHasProperties(RegisterJob registerJob, int expectedId,
      RegisterJobTrigger expectedJobTrigger, String expectedJobName, UUID expectedUploaderId,
      RegisterJobStatus expectedJobStatus, List<RegisterJobError> expectedErrors,
      String expectedCorrelationId) {
    assertThat(registerJob)
        .hasId(expectedId)
        .wasTriggeredBy(expectedJobTrigger)
        .hasName(expectedJobName)
        .wasUploadedBy(expectedUploaderId)
        .isInStatus(expectedJobStatus)
        .hasErrors(expectedErrors)
        .hasCorrelationId(expectedCorrelationId);
  }

  private void updateErrors(int autoGeneratedId, List<RegisterJobError> newErrors) {
    registerJobRepository.updateErrors(autoGeneratedId, newErrors);
  }

  private void queryForNonExistingRegisterJobById() {
    Optional<RegisterJob> fetchedRegisterJobOptional = registerJobRepository.findById(99887766);
    assertThat(fetchedRegisterJobOptional).isEmpty();
  }

  private void queryForNonExistingRegisterJobByName() {
    Optional<RegisterJob> fetchedRegisterJobOptional = registerJobRepository
        .findByName(NOT_EXISTING_REGISTER_JOB_NAME);
    assertThat(fetchedRegisterJobOptional).isEmpty();
  }

  static Stream<Arguments> activatedJobsForGivenLicensingAuthorities() {
    return Stream.of(
        Arguments.arguments(Collections.singleton(LicensingAuthority.withNameOnly("Leeds")), 1),
        Arguments.arguments(Collections.singleton(LicensingAuthority.withNameOnly("Birmingham")), 1),
        Arguments.arguments(ImmutableSet.of(LicensingAuthority.withNameOnly("Leeds"), LicensingAuthority.withNameOnly("Birmingham")),2)
    );
  }
}
