package uk.gov.caz.accounts.service.registerjob;

import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;
import javax.transaction.Transactional;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import uk.gov.caz.accounts.model.registerjob.RegisterJob;
import uk.gov.caz.accounts.model.registerjob.RegisterJobError;
import uk.gov.caz.accounts.model.registerjob.RegisterJobErrors;
import uk.gov.caz.accounts.model.registerjob.RegisterJobName;
import uk.gov.caz.accounts.model.registerjob.RegisterJobStatus;
import uk.gov.caz.accounts.model.registerjob.RegisterJobTrigger;
import uk.gov.caz.accounts.model.registerjob.ValidationError;
import uk.gov.caz.accounts.repository.RegisterJobRepository;

/**
 * This class acts as a supervisor around running Register Jobs. It manages status and database
 * updates of any job that will be passed to it by implementation of {@link RegisterJobInvoker}
 * interface.
 */
@Service
@AllArgsConstructor
@Slf4j
public class RegisterJobSupervisor {

  private final RegisterJobRepository registerJobRepository;
  private final RegisterJobNameGenerator registerJobNameGenerator;

  @FunctionalInterface
  public interface RegisterJobInvoker {

    void invoke(int registerJobId);
  }

  /**
   * Parameters required to start register job.
   */
  @Value
  @Builder
  public static class StartParams {

    /**
     * Informs supervisor of the source the job is originating from.
     */
    RegisterJobTrigger registerJobTrigger;

    /**
     * Allows to add our own suffix to job name generated by supervisor.
     */
    String registerJobNameSuffix;

    /**
     * CorrelationID to track the request from the API gateway through the Enquiries stack.
     */
    String correlationId;

    /**
     * Identifies user who started register job.
     */
    UUID uploaderId;

    /**
     * Implementation of {@link RegisterJobInvoker} that will start register job.
     */
    RegisterJobInvoker registerJobInvoker;
  }

  /**
   * Starts Register Job specified in passed implementation of {@link RegisterJobInvoker} interface
   * and supervises it. It will create proper Register Job database entries and provide name as a
   * handle for future interactions with supervisor.
   *
   * @param params {@link StartParams} with parameters required to start register job.
   * @return Name of started Register Job. Clients can use to to poll or query for status of
   *     Register Job. Useful for debugging and logging purposes as well.
   */
  public RegisterJobName start(StartParams params) {
    RegisterJobName jobName = registerJobNameGenerator.generate(params.registerJobNameSuffix,
        params.registerJobTrigger);
    RegisterJob registerJob = createNewRegisterJob(params.registerJobTrigger, params.correlationId,
        jobName, params.uploaderId);

    RegisterJob registerJobWithId = registerJobRepository.save(registerJob);

    log.info("About to invoke register job with id '{}' and name '{}'", registerJobWithId.getId(),
        jobName.getValue());
    params.registerJobInvoker.invoke(registerJobWithId.getId());
    return jobName;
  }

  private RegisterJob createNewRegisterJob(RegisterJobTrigger registerJobTrigger,
      String correlationId, RegisterJobName jobName, UUID uploaderId) {
    return RegisterJob.builder()
        .trigger(registerJobTrigger)
        .uploaderId(uploaderId)
        .status(RegisterJobStatus.STARTING)
        .jobName(jobName)
        .correlationId(correlationId)
        .errors(new RegisterJobErrors(Collections.emptyList()))
        .build();
  }

  /**
   * Will try to find {@link RegisterJob} with name passed in parameter.
   *
   * @param registerJobName Name of {@link RegisterJob} that will be fetched.
   * @return {@link Optional} of {@link RegisterJob} - if RegisterJob with specified name exists it
   *     will returned in the Optional otherwise it will return empty one.
   */
  public Optional<RegisterJob> findJobWithName(RegisterJobName registerJobName) {
    return registerJobRepository.findByJobName(registerJobName);
  }

  /**
   * Updates status of existing job.
   *
   * @param registerJobId ID of register job.
   * @param newStatus New status to set.
   * @return {@link RegisterJob} with the new status set.
   */
  @Transactional
  public RegisterJob updateStatus(int registerJobId, RegisterJobStatus newStatus) {
    RegisterJob registerJob = registerJobRepository.findById(registerJobId)
        .orElseThrow(() -> new IllegalStateException("Job (id: " + registerJobId + ") not found"));
    registerJob.setStatus(newStatus);
    return registerJob;
  }

  /**
   * Updates errors of existing job.
   *
   * @param registerJob {@link RegisterJob} entity which is to be updated
   * @param validationErrors Validation errors whose details need to be saved in the database
   */
  private void addErrors(RegisterJob registerJob, List<ValidationError> validationErrors) {
    List<RegisterJobError> errors = validationErrors.stream()
        .map(RegisterJobError::from)
        .collect(Collectors.toList());
    RegisterJobErrors registerJobErrors = new RegisterJobErrors(errors);
    registerJob.setErrors(registerJobErrors);
  }

  /**
   * Updates status and errors of an existing job.
   *  @param registerJobId ID of the register job.
   * @param jobStatus Status which will be set against the job.
   * @param validationErrors Validation errors whose details need to be saved in the database
   * @return returns the updated {@link RegisterJob} entity.
   */
  @Transactional
  public RegisterJob markFailureWithValidationErrors(int registerJobId, RegisterJobStatus jobStatus,
      List<ValidationError> validationErrors) {
    RegisterJob registerJob = updateStatus(registerJobId, jobStatus);
    addErrors(registerJob, validationErrors);
    return registerJob;
  }
}
